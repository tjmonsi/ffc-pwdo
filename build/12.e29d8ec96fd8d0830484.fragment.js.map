{"version":3,"sources":["webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./app/node_modules/@polymer/polymer/lib/utils/gestures.js","webpack:///./app/pages/page-not-authorized/style.scss?e9c9","webpack:///./app/pages/page-not-authorized/style.scss","webpack:///./app/pages/page-not-authorized/template.html","webpack:///./app/pages/page-not-authorized/index.js","webpack:///./app/node_modules/@polymer/polymer/lib/mixins/gesture-event-listeners.js"],"names":["module","exports","useSourceMap","list","toString","this","map","item","content","cssMapping","btoa","sourceMapping","sourceMap","unescape","encodeURIComponent","JSON","stringify","sourceURLs","sources","source","sourceRoot","concat","join","cssWithMappingToString","i","modules","mediaQuery","alreadyImportedModules","length","id","push","deepTargetFind","_findOriginalTarget","_handleNative","_handleTouchAction","addListener","removeListener","_add","_remove","register","_findRecognizerByEvent","setTouchAction","resetMouseCanceller","POINTERSTATE","mouse","mouseIgnoreJob","flush","__webpack_require__","_async","_debounce","HAS_NATIVE_TA","document","head","style","touchAction","GESTURE_KEY","HANDLED_OBJ","TOUCH_ACTION","MOUSE_TIMEOUT","MOUSE_EVENTS","MOUSE_WHICH_TO_BUTTONS","MOUSE_HAS_BUTTONS","MouseEvent","buttons","e","SUPPORTS_PASSIVE","opts","Object","defineProperty","get","window","addEventListener","removeEventListener","IS_TOUCH_ONLY","navigator","userAgent","match","GestureRecognizer","prototype","reset","mousedown","mousemove","mouseup","touchstart","touchmove","touchend","click","mouseCanceller","mouseEvent","sc","sourceCapabilities","firesTouchEvents","skip","type","path","composedPath","target","preventDefault","stopPropagation","setupTeardownMouseCanceller","setup","en","events","hasLeftMouseButton","ev","indexOf","undefined","which","Boolean","button","touch","x","y","scrollDecided","trackDocument","stateObj","movefn","upfn","untrackDocument","Debouncer","debounce","timeOut","after","passive","gestures","recognizers","node","elementFromPoint","next","shadowRoot","ShadyDOM","handled","gobj","currentTarget","gs","slice","t","changedTouches","touches","identifier","r","name","flow","start","clientX","clientY","ta","n","firstTouchAction","prevent","dx","Math","abs","dy","cancelable","evType","handler","recognizer","deps","dep","gd","_count","recog","emits","evName","j","value","_fire","detail","Event","bubbles","composed","dispatchEvent","defaultPrevented","preventer","sourceEvent","info","end","self","event","state","started","moves","addMove","move","shift","hasMovedEnough","ct","secondlast","lastmove","ddx","ddy","hover","NaN","save","forward","isNaN","nodeType","Node","ELEMENT_NODE","bcr","getBoundingClientRect","pageX","pageY","left","right","top","bottom","isSyntheticClick","findOriginalTarget","add","remove","result","_polymerElement","_gestureEventListeners","_window","Component","GestureEventListeners","Element","css","template","customElements","is","console","warn","define","_mixin","dedupingMixin","superClass","_superClass","_classCallCheck","_possibleConstructorReturn","__proto__","getPrototypeOf","apply","arguments","_inherits","_createClass","key","eventName","_get","call"],"mappings":"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","file":"12.e29d8ec96fd8d0830484.fragment.js","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","import './boot.js';\nimport { timeOut } from './async.js';\nimport { Debouncer } from './debounce.js';\n\n// detect native touch action support\nlet HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nlet GESTURE_KEY = '__polymerGestures';\nlet HANDLED_OBJ = '__polymerGesturesHandled';\nlet TOUCH_ACTION = '__polymerGesturesTouchAction';\n// radius for tap and track\nlet TAP_DISTANCE = 25;\nlet TRACK_DISTANCE = 5;\n// number of last N track positions to keep\nlet TRACK_LENGTH = 2;\n\n// Disabling \"mouse\" handlers for 2500ms is enough\nlet MOUSE_TIMEOUT = 2500;\nlet MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];\n// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons\nlet MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];\nlet MOUSE_HAS_BUTTONS = (function() {\n  try {\n    return new MouseEvent('test', {buttons: 1}).buttons === 1;\n  } catch (e) {\n    return false;\n  }\n})();\n\n/* eslint no-empty: [\"error\", { \"allowEmptyCatch\": true }] */\n// check for passive event listeners\nlet SUPPORTS_PASSIVE = false;\n(function() {\n  try {\n    let opts = Object.defineProperty({}, 'passive', {get: function() {SUPPORTS_PASSIVE = true;}});\n    window.addEventListener('test', null, opts);\n    window.removeEventListener('test', null, opts);\n  } catch(e) {}\n})();\n\n// Check for touch-only devices\nlet IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);\n\nlet GestureRecognizer = function(){}; // eslint-disable-line no-unused-vars\nGestureRecognizer.prototype.reset = function(){};\n/** @type {function(MouseEvent) | undefined} */\nGestureRecognizer.prototype.mousedown;\n/** @type {(function(MouseEvent) | undefined)} */\nGestureRecognizer.prototype.mousemove;\n/** @type {(function(MouseEvent) | undefined)} */\nGestureRecognizer.prototype.mouseup;\n/** @type {(function(TouchEvent) | undefined)} */\nGestureRecognizer.prototype.touchstart;\n/** @type {(function(TouchEvent) | undefined)} */\nGestureRecognizer.prototype.touchmove;\n/** @type {(function(TouchEvent) | undefined)} */\nGestureRecognizer.prototype.touchend;\n/** @type {(function(MouseEvent) | undefined)} */\nGestureRecognizer.prototype.click;\n\n// touch will make synthetic mouse events\n// `preventDefault` on touchend will cancel them,\n// but this breaks `<input>` focus and link clicks\n// disable mouse handlers for MOUSE_TIMEOUT ms after\n// a touchend to ignore synthetic mouse events\nlet mouseCanceller = function(mouseEvent) {\n  // Check for sourceCapabilities, used to distinguish synthetic events\n  // if mouseEvent did not come from a device that fires touch events,\n  // it was made by a real mouse and should be counted\n  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents\n  let sc = mouseEvent.sourceCapabilities;\n  if (sc && !sc.firesTouchEvents) {\n    return;\n  }\n  // skip synthetic mouse events\n  mouseEvent[HANDLED_OBJ] = {skip: true};\n  // disable \"ghost clicks\"\n  if (mouseEvent.type === 'click') {\n    let path = mouseEvent.composedPath && mouseEvent.composedPath();\n    if (path) {\n      for (let i = 0; i < path.length; i++) {\n        if (path[i] === POINTERSTATE.mouse.target) {\n          return;\n        }\n      }\n    }\n    mouseEvent.preventDefault();\n    mouseEvent.stopPropagation();\n  }\n};\n\n/**\n * @param {boolean=} setup True to add, false to remove.\n */\nfunction setupTeardownMouseCanceller(setup) {\n  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;\n  for (let i = 0, en; i < events.length; i++) {\n    en = events[i];\n    if (setup) {\n      document.addEventListener(en, mouseCanceller, true);\n    } else {\n      document.removeEventListener(en, mouseCanceller, true);\n    }\n  }\n}\n\nfunction ignoreMouse(e) {\n  if (!POINTERSTATE.mouse.mouseIgnoreJob) {\n    setupTeardownMouseCanceller(true);\n  }\n  let unset = function() {\n    setupTeardownMouseCanceller();\n    POINTERSTATE.mouse.target = null;\n    POINTERSTATE.mouse.mouseIgnoreJob = null;\n  };\n  POINTERSTATE.mouse.target = e.composedPath()[0];\n  POINTERSTATE.mouse.mouseIgnoreJob = Debouncer.debounce(\n        POINTERSTATE.mouse.mouseIgnoreJob\n      , timeOut.after(MOUSE_TIMEOUT)\n      , unset);\n}\n\n/**\n * @param {MouseEvent} ev event to test for left mouse button down\n * @return {boolean} has left mouse button down\n */\nfunction hasLeftMouseButton(ev) {\n  let type = ev.type;\n  // exit early if the event is not a mouse event\n  if (MOUSE_EVENTS.indexOf(type) === -1) {\n    return false;\n  }\n  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)\n  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)\n  if (type === 'mousemove') {\n    // allow undefined for testing events\n    let buttons = ev.buttons === undefined ? 1 : ev.buttons;\n    if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {\n      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n    }\n    // buttons is a bitmask, check that the left button bit is set (1)\n    return Boolean(buttons & 1);\n  } else {\n    // allow undefined for testing events\n    let button = ev.button === undefined ? 0 : ev.button;\n    // ev.button is 0 in mousedown/mouseup/click for left button activation\n    return button === 0;\n  }\n}\n\nfunction isSyntheticClick(ev) {\n  if (ev.type === 'click') {\n    // ev.detail is 0 for HTMLElement.click in most browsers\n    if (ev.detail === 0) {\n      return true;\n    }\n    // in the worst case, check that the x/y position of the click is within\n    // the bounding box of the target of the event\n    // Thanks IE 10 >:(\n    let t = _findOriginalTarget(ev);\n    // make sure the target of the event is an element so we can use getBoundingClientRect,\n    // if not, just assume it is a synthetic click\n    if (!t.nodeType || /** @type {Element} */(t).nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n    let bcr = /** @type {Element} */(t).getBoundingClientRect();\n    // use page x/y to account for scrolling\n    let x = ev.pageX, y = ev.pageY;\n    // ev is a synthetic click if the position is outside the bounding box of the target\n    return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));\n  }\n  return false;\n}\n\nlet POINTERSTATE = {\n  mouse: {\n    target: null,\n    mouseIgnoreJob: null\n  },\n  touch: {\n    x: 0,\n    y: 0,\n    id: -1,\n    scrollDecided: false\n  }\n};\n\nfunction firstTouchAction(ev) {\n  let ta = 'auto';\n  let path = ev.composedPath && ev.composedPath();\n  if (path) {\n    for (let i = 0, n; i < path.length; i++) {\n      n = path[i];\n      if (n[TOUCH_ACTION]) {\n        ta = n[TOUCH_ACTION];\n        break;\n      }\n    }\n  }\n  return ta;\n}\n\nfunction trackDocument(stateObj, movefn, upfn) {\n  stateObj.movefn = movefn;\n  stateObj.upfn = upfn;\n  document.addEventListener('mousemove', movefn);\n  document.addEventListener('mouseup', upfn);\n}\n\nfunction untrackDocument(stateObj) {\n  document.removeEventListener('mousemove', stateObj.movefn);\n  document.removeEventListener('mouseup', stateObj.upfn);\n  stateObj.movefn = null;\n  stateObj.upfn = null;\n}\n\n// use a document-wide touchend listener to start the ghost-click prevention mechanism\n// Use passive event listeners, if supported, to not affect scrolling performance\ndocument.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {passive: true} : false);\n\nexport const gestures = {};\nexport const recognizers = [];\n\nexport function deepTargetFind(x, y) {\n  let node = document.elementFromPoint(x, y);\n  let next = node;\n  // this code path is only taken when native ShadowDOM is used\n  // if there is a shadowroot, it may have a node at x/y\n  // if there is not a shadowroot, exit the loop\n  while (next && next.shadowRoot && !window.ShadyDOM) {\n    // if there is a node at x/y in the shadowroot, look deeper\n    let oldNext = next;\n    next = next.shadowRoot.elementFromPoint(x, y);\n    // on Safari, elementFromPoint may return the shadowRoot host\n    if (oldNext === next) {\n      break;\n    }\n    if (next) {\n      node = next;\n    }\n  }\n  return node;\n}\n\nexport function _findOriginalTarget(ev) {\n  // shadowdom\n  if (ev.composedPath) {\n    return /** @type {EventTarget} */(ev.composedPath()[0]);\n  }\n  // shadydom\n  return ev.target;\n}\n\nexport function _handleNative(ev) {\n  let handled;\n  let type = ev.type;\n  let node = ev.currentTarget;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    return;\n  }\n  let gs = gobj[type];\n  if (!gs) {\n    return;\n  }\n  if (!ev[HANDLED_OBJ]) {\n    ev[HANDLED_OBJ] = {};\n    if (type.slice(0, 5) === 'touch') {\n      ev = /** @type {TouchEvent} */(ev); // eslint-disable-line no-self-assign\n      let t = ev.changedTouches[0];\n      if (type === 'touchstart') {\n        // only handle the first finger\n        if (ev.touches.length === 1) {\n          POINTERSTATE.touch.id = t.identifier;\n        }\n      }\n      if (POINTERSTATE.touch.id !== t.identifier) {\n        return;\n      }\n      if (!HAS_NATIVE_TA) {\n        if (type === 'touchstart' || type === 'touchmove') {\n          _handleTouchAction(ev);\n        }\n      }\n    }\n  }\n  handled = ev[HANDLED_OBJ];\n  // used to ignore synthetic mouse events\n  if (handled.skip) {\n    return;\n  }\n  // reset recognizer state\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\n        r.reset();\n      }\n    }\n  }\n  // enforce gesture recognizer order\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    if (gs[r.name] && !handled[r.name]) {\n      handled[r.name] = true;\n      r[type](ev);\n    }\n  }\n}\n\nexport function _handleTouchAction(ev) {\n  let t = ev.changedTouches[0];\n  let type = ev.type;\n  if (type === 'touchstart') {\n    POINTERSTATE.touch.x = t.clientX;\n    POINTERSTATE.touch.y = t.clientY;\n    POINTERSTATE.touch.scrollDecided = false;\n  } else if (type === 'touchmove') {\n    if (POINTERSTATE.touch.scrollDecided) {\n      return;\n    }\n    POINTERSTATE.touch.scrollDecided = true;\n    let ta = firstTouchAction(ev);\n    let prevent = false;\n    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\n    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\n    if (!ev.cancelable) {\n      // scrolling is happening\n    } else if (ta === 'none') {\n      prevent = true;\n    } else if (ta === 'pan-x') {\n      prevent = dy > dx;\n    } else if (ta === 'pan-y') {\n      prevent = dx > dy;\n    }\n    if (prevent) {\n      ev.preventDefault();\n    } else {\n      prevent('track');\n    }\n  }\n}\n\nexport function addListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _add(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\nexport function removeListener(node, evType, handler) {\n  if (gestures[evType]) {\n    _remove(node, evType, handler);\n    return true;\n  }\n  return false;\n}\n\nexport function _add(node, evType, handler) {\n  let recognizer = gestures[evType];\n  let deps = recognizer.deps;\n  let name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (!gobj) {\n    node[GESTURE_KEY] = gobj = {};\n  }\n  for (let i = 0, dep, gd; i < deps.length; i++) {\n    dep = deps[i];\n    // don't add mouse handlers on iOS because they cause gray selection overlays\n    if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {\n      continue;\n    }\n    gd = gobj[dep];\n    if (!gd) {\n      gobj[dep] = gd = {_count: 0};\n    }\n    if (gd._count === 0) {\n      node.addEventListener(dep, _handleNative);\n    }\n    gd[name] = (gd[name] || 0) + 1;\n    gd._count = (gd._count || 0) + 1;\n  }\n  node.addEventListener(evType, handler);\n  if (recognizer.touchAction) {\n    setTouchAction(node, recognizer.touchAction);\n  }\n}\n\nexport function _remove(node, evType, handler) {\n  let recognizer = gestures[evType];\n  let deps = recognizer.deps;\n  let name = recognizer.name;\n  let gobj = node[GESTURE_KEY];\n  if (gobj) {\n    for (let i = 0, dep, gd; i < deps.length; i++) {\n      dep = deps[i];\n      gd = gobj[dep];\n      if (gd && gd[name]) {\n        gd[name] = (gd[name] || 1) - 1;\n        gd._count = (gd._count || 1) - 1;\n        if (gd._count === 0) {\n          node.removeEventListener(dep, _handleNative);\n        }\n      }\n    }\n  }\n  node.removeEventListener(evType, handler);\n}\n\nexport function register(recog) {\n  recognizers.push(recog);\n  for (let i = 0; i < recog.emits.length; i++) {\n    gestures[recog.emits[i]] = recog;\n  }\n}\n\nexport function _findRecognizerByEvent(evName) {\n  for (let i = 0, r; i < recognizers.length; i++) {\n    r = recognizers[i];\n    for (let j = 0, n; j < r.emits.length; j++) {\n      n = r.emits[j];\n      if (n === evName) {\n        return r;\n      }\n    }\n  }\n  return null;\n}\n\nexport function setTouchAction(node, value) {\n  if (HAS_NATIVE_TA) {\n    node.style.touchAction = value;\n  }\n  node[TOUCH_ACTION] = value;\n}\n\nexport function _fire(target, type, detail) {\n  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });\n  ev.detail = detail;\n  target.dispatchEvent(ev);\n  // forward `preventDefault` in a clean way\n  if (ev.defaultPrevented) {\n    let preventer = detail.preventer || detail.sourceEvent;\n    if (preventer && preventer.preventDefault) {\n      preventer.preventDefault();\n    }\n  }\n}\n\nexport function prevent(evName) {\n  let recognizer = _findRecognizerByEvent(evName);\n  if (recognizer.info) {\n    recognizer.info.prevent = true;\n  }\n}\n\nexport function resetMouseCanceller() {\n  if (POINTERSTATE.mouse.mouseIgnoreJob) {\n    POINTERSTATE.mouse.mouseIgnoreJob.flush();\n  }\n}\n\n/* eslint-disable valid-jsdoc */\n\nregister({\n  name: 'downup',\n  deps: ['mousedown', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['down', 'up'],\n\n  info: {\n    movefn: null,\n    upfn: null\n  },\n\n  /** @this {GestureRecognizer} */\n  reset: function() {\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   */\n  mousedown: function(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    let t = _findOriginalTarget(e);\n    let self = this;\n    let movefn = function movefn(e) {\n      if (!hasLeftMouseButton(e)) {\n        self._fire('up', t, e);\n        untrackDocument(self.info);\n      }\n    };\n    let upfn = function upfn(e) {\n      if (hasLeftMouseButton(e)) {\n        self._fire('up', t, e);\n      }\n      untrackDocument(self.info);\n    };\n    trackDocument(this.info, movefn, upfn);\n    this._fire('down', t, e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   */\n  touchstart: function(e) {\n    this._fire('down', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   */\n  touchend: function(e) {\n    this._fire('up', _findOriginalTarget(e), e.changedTouches[0], e);\n  },\n  /**\n   * @param {string} type\n   * @param {EventTarget} target\n   * @param {Event} event\n   * @param {Function} preventer\n   */\n  _fire: function(type, target, event, preventer) {\n    _fire(target, type, {\n      x: event.clientX,\n      y: event.clientY,\n      sourceEvent: event,\n      preventer: preventer,\n      prevent: function(e) {\n        return prevent(e);\n      }\n    });\n  }\n});\n\nregister({\n  name: 'track',\n  touchAction: 'none',\n  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['mouseup', 'touchend']\n  },\n  emits: ['track'],\n\n  info: {\n    x: 0,\n    y: 0,\n    state: 'start',\n    started: false,\n    moves: [],\n    /** @this {GestureRecognizer} */\n    addMove: function(move) {\n      if (this.moves.length > TRACK_LENGTH) {\n        this.moves.shift();\n      }\n      this.moves.push(move);\n    },\n    movefn: null,\n    upfn: null,\n    prevent: false\n  },\n\n  /** @this {GestureRecognizer} */\n  reset: function() {\n    this.info.state = 'start';\n    this.info.started = false;\n    this.info.moves = [];\n    this.info.x = 0;\n    this.info.y = 0;\n    this.info.prevent = false;\n    untrackDocument(this.info);\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {number} x\n   * @param {number} y\n   * @return {boolean}\n   */\n  hasMovedEnough: function(x, y) {\n    if (this.info.prevent) {\n      return false;\n    }\n    if (this.info.started) {\n      return true;\n    }\n    let dx = Math.abs(this.info.x - x);\n    let dy = Math.abs(this.info.y - y);\n    return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   */\n  mousedown: function(e) {\n    if (!hasLeftMouseButton(e)) {\n      return;\n    }\n    let t = _findOriginalTarget(e);\n    let self = this;\n    let movefn = function movefn(e) {\n      let x = e.clientX, y = e.clientY;\n      if (self.hasMovedEnough(x, y)) {\n        // first move is 'start', subsequent moves are 'move', mouseup is 'end'\n        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';\n        if (self.info.state === 'start') {\n          // if and only if tracking, always prevent tap\n          prevent('tap');\n        }\n        self.info.addMove({x: x, y: y});\n        if (!hasLeftMouseButton(e)) {\n          // always _fire \"end\"\n          self.info.state = 'end';\n          untrackDocument(self.info);\n        }\n        self._fire(t, e);\n        self.info.started = true;\n      }\n    };\n    let upfn = function upfn(e) {\n      if (self.info.started) {\n        movefn(e);\n      }\n\n      // remove the temporary listeners\n      untrackDocument(self.info);\n    };\n    // add temporary document listeners as mouse retargets\n    trackDocument(this.info, movefn, upfn);\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   */\n  touchstart: function(e) {\n    let ct = e.changedTouches[0];\n    this.info.x = ct.clientX;\n    this.info.y = ct.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   */\n  touchmove: function(e) {\n    let t = _findOriginalTarget(e);\n    let ct = e.changedTouches[0];\n    let x = ct.clientX, y = ct.clientY;\n    if (this.hasMovedEnough(x, y)) {\n      if (this.info.state === 'start') {\n        // if and only if tracking, always prevent tap\n        prevent('tap');\n      }\n      this.info.addMove({x: x, y: y});\n      this._fire(t, ct);\n      this.info.state = 'track';\n      this.info.started = true;\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   */\n  touchend: function(e) {\n    let t = _findOriginalTarget(e);\n    let ct = e.changedTouches[0];\n    // only trackend if track was started and not aborted\n    if (this.info.started) {\n      // reset started state on up\n      this.info.state = 'end';\n      this.info.addMove({x: ct.clientX, y: ct.clientY});\n      this._fire(t, ct, e);\n    }\n  },\n\n  /**\n   * @this {GestureRecognizer}\n   * @param {EventTarget} target\n   * @param {Touch} touch\n   */\n  _fire: function(target, touch) {\n    let secondlast = this.info.moves[this.info.moves.length - 2];\n    let lastmove = this.info.moves[this.info.moves.length - 1];\n    let dx = lastmove.x - this.info.x;\n    let dy = lastmove.y - this.info.y;\n    let ddx, ddy = 0;\n    if (secondlast) {\n      ddx = lastmove.x - secondlast.x;\n      ddy = lastmove.y - secondlast.y;\n    }\n    _fire(target, 'track', {\n      state: this.info.state,\n      x: touch.clientX,\n      y: touch.clientY,\n      dx: dx,\n      dy: dy,\n      ddx: ddx,\n      ddy: ddy,\n      sourceEvent: touch,\n      hover: function() {\n        return deepTargetFind(touch.clientX, touch.clientY);\n      }\n    });\n  }\n\n});\n\nregister({\n  name: 'tap',\n  deps: ['mousedown', 'click', 'touchstart', 'touchend'],\n  flow: {\n    start: ['mousedown', 'touchstart'],\n    end: ['click', 'touchend']\n  },\n  emits: ['tap'],\n  info: {\n    x: NaN,\n    y: NaN,\n    prevent: false\n  },\n  /** @this {GestureRecognizer} */\n  reset: function() {\n    this.info.x = NaN;\n    this.info.y = NaN;\n    this.info.prevent = false;\n  },\n  /** @this {GestureRecognizer} */\n  save: function(e) {\n    this.info.x = e.clientX;\n    this.info.y = e.clientY;\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   */\n  mousedown: function(e) {\n    if (hasLeftMouseButton(e)) {\n      this.save(e);\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {MouseEvent} e\n   */\n  click: function(e) {\n    if (hasLeftMouseButton(e)) {\n      this.forward(e);\n    }\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   */\n  touchstart: function(e) {\n    this.save(e.changedTouches[0], e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {TouchEvent} e\n   */\n  touchend: function(e) {\n    this.forward(e.changedTouches[0], e);\n  },\n  /**\n   * @this {GestureRecognizer}\n   * @param {Event | Touch} e\n   * @param {Event=} preventer\n   */\n  forward: function(e, preventer) {\n    let dx = Math.abs(e.clientX - this.info.x);\n    let dy = Math.abs(e.clientY - this.info.y);\n    // find original target from `preventer` for TouchEvents, or `e` for MouseEvents\n    let t = _findOriginalTarget((preventer || e));\n    // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`\n    if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {\n      // prevent taps from being generated if an event has canceled them\n      if (!this.info.prevent) {\n        _fire(t, 'tap', {\n          x: e.clientX,\n          y: e.clientY,\n          sourceEvent: e,\n          preventer: preventer\n        });\n      }\n    }\n  }\n});\n\nexport const findOriginalTarget = _findOriginalTarget;\nexport const add = addListener;\nexport const remove = removeListener;\n","\n        var result = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/postcss-loader/lib/index.js!../../../node_modules/sass-loader/lib/loader.js!./style.scss\");\n\n        if (typeof result === \"string\") {\n            module.exports = result;\n        } else {\n            module.exports = result.toString();\n        }\n    ","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n","module.exports = \"Not Authorized Page\\n\"","import { Element } from '@polymer/polymer/polymer-element';\nimport { GestureEventListeners } from '@polymer/polymer/lib/mixins/gesture-event-listeners';\nimport { customElements } from 'global/window';\nimport css from './style.scss';\nimport template from './template.html';\n\nclass Component extends GestureEventListeners(Element) {\n  static get is () { return 'page-not-authorized'; }\n\n  static get template () {\n    return `\n      <style>\n        ${css}\n      </style>\n      ${template}\n    `;\n  }\n}\n\n!customElements.get(Component.is)\n  ? customElements.define(Component.is, Component)\n  : console.warn(`${Component.is} is already defined`);\n","import '../utils/boot.js';\nimport { dedupingMixin } from '../utils/mixin.js';\nimport * as gestures$0 from '../utils/gestures.js';\n\n/**\n * @const {Polymer.Gestures}\n */\nconst gestures = gestures$0;\n\nexport const GestureEventListeners = dedupingMixin(superClass => {\n\n  /**\n   * @polymer\n   * @mixinClass\n   * @implements {Polymer_GestureEventListeners}\n   */\n  class GestureEventListeners extends superClass {\n\n    _addEventListenerToNode(node, eventName, handler) {\n      if (!gestures.addListener(node, eventName, handler)) {\n        super._addEventListenerToNode(node, eventName, handler);\n      }\n    }\n\n    _removeEventListenerFromNode(node, eventName, handler) {\n      if (!gestures.removeListener(node, eventName, handler)) {\n        super._removeEventListenerFromNode(node, eventName, handler);\n      }\n    }\n\n  }\n\n  return GestureEventListeners;\n\n});\n"],"sourceRoot":""}